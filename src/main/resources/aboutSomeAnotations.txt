
https://javarush.com/quests/lectures/questhibernate.level14.lecture01
Если параметр fetch равен EAGER, то при загрузке родительской сущности будут загружены и все ее дочерние сущности.
Кроме того, Hibernate постарается сделать это одним SQL-запросом, сгенерировав здоровенный запрос и сразу получив все данные.

Если параметр fetch принимает значение LAZY, то при загрузке родительской сущности, дочерняя сущность загружена не будет.
Вместо нее будет создан proxy-объект.

Если ты не указал параметр fetch для аннотации @ManyTo…, то Hibernate будет использовать значения по умолчанию.

Они немного отличаются для различных типов аннотаций. Для аннотаций @OneToOne и @ManyToOne – это EAGER,
для аннотаций @OneToMany и @ManyToMany – это LAZY. Запомнить просто – если мы ссылаемся на один объект,
то он будет загружен полностью. Если ссылаемся на коллекцию, то она будет загружена при первом обращении к ней.
------------------------------------------------------------------------------------------------------------------
Благодаря аннотации @Embedded во время сохранения объекта Hibernate поймет,
 что поля класса UserAddress нужно обрабатывать как поля самого класса User.

 CascadeType.ALL https://javarush.com/quests/lectures/questhibernate.level13.lecture05

 ---------------------------------------------------------------------------------------------------------------------


